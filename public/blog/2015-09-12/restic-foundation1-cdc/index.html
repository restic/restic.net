<!DOCTYPE html>
<html lang="en-us">
  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="generator" content="Hugo" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    restic &middot;
    
      Foundation - Introducing Content Defined Chunking (CDC)
    
  </title>

  
  <link rel="stylesheet" href="/css/poole.css">
  <link rel="stylesheet" href="/css/syntax.css">
  <link rel="stylesheet" href="/css/hyde.css">
  <link rel="stylesheet" href="/css/others.css">
  <link rel="stylesheet" href="/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://restic.net/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="https://restic.net/favicon.ico">

  
  
  <link rel="canonical" href="https://restic.net/blog/2015-09-12/restic-foundation1-cdc/">

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>


  <body>
    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <h1>
        <a href="https://restic.net/">restic</a>
      </h1>
      <p class="lead">Backups done right!</p>
    </div>

    <nav class="sidebar-nav">
      <a class="sidebar-nav-item" href="https://restic.net/">Home</a>
          <a class="sidebar-nav-item" href="https://restic.net/blog/">Blog</a>

      <a class="sidebar-nav-item" href="https://forum.restic.net/">Forum</a>
      <a class="sidebar-nav-item" href="https://restic.readthedocs.io/en/stable/">Docs</a>
      <a class="sidebar-nav-item" href="https://restic.readthedocs.io/en/latest/">Docs (dev)</a>

      <a class="sidebar-nav-item" href="https://github.com/restic/restic">
        <i class="fa fa-github" aria-hidden="true"></i>
        GitHub Project
      </a>

      <a class="sidebar-nav-item" href="https://twitter.com/resticbackup">
        <i class="fa fa-twitter" aria-hidden="true"></i>
        @<span class="username">resticbackup</span>
      </a>
    </nav>

    
  </div>
</div>


    <div class="content container">
      <div class="post">
        <h1 class="post-title">Foundation - Introducing Content Defined Chunking (CDC)</h1>
        <span class="post-date">12 Sep 2015</span>
        <p>This post will explain Content Defined Chunking (CDC) and how it is used by
restic.</p>
<p>Backup programs need to deal with large volumes of changing data. Saving the
whole copy of each file again to the backup location when a subsequent (usually
called &ldquo;incremental&rdquo;) backup is created is not efficient. Over time, different
strategies have emerged to handle data in such a case.</p>
<p>In a backup program, data de-duplication can be applied in two locations:
Removing duplicate data from the same or different files within the same backup
process (<em>inter-file de-duplication</em>), e.g. during the initial backup, or
removing it between several backups that contain some of the same data
(<em>inter-backup de-duplication</em>). While the former is desirable to have, the
latter is much more important.</p>
<h3 id="strategies">Strategies</h3>
<p>The most basic strategy is to only save files that have changed since the last
backup, this is where the term &ldquo;incremental&rdquo; backup comes from. This way,
unmodified files are not stored again on subsequent backups. But what happens if
just a small portion of a large file is modified? Using this strategy, the
modified file will be saved again, although most of it did not change.</p>
<p>A better idea is to split files into smaller fixed-size pieces (called &ldquo;chunks&rdquo;
in the following) of e.g. 1MiB in size. When the backup program saves a file to
the backup location, it is sufficient to save all chunks and the list of chunks
the file consists of. These chunks can be identified for example by the SHA-256
hash of the content, so duplicate chunks can be detected and saved only once.
This way, for a file containing of a large number of consecutive null bytes,
only one chunk of null bytes needs to be stored.</p>
<p>On a subsequent backup, unmodified files are not saved again because all chunks
have already been saved before. Modified files on the other hand are split into
chunks again, and new chunks are saved to the backup location.</p>
<p>But what happens when the user adds a byte to the beginning of the file? The
chunk boundaries (where a chunk ends and the next begins) would shift by one
byte, changing every chunk in the file. When the backup program now splits the
file into fixed-sized chunks, it would (in most cases) end up with a list of
different chunks, so it needs to save every chunk as a new chunk to the backup
location. This is not satisfactory for a modern backup program.</p>
<h3 id="content-defined-chunking">Content Defined Chunking</h3>
<p>Restic works a bit differently. It also operates on chunks of data from files
and only upload new chunks, but uses a more sophisticated approach for
splitting files into chunks called <em>Content Defined Chunking</em>. It works by
splitting a file into chunks based on the contents of the file, rather than
always splitting after a fixed number of bytes.</p>
<p>In the following, the function $$F(b_0…b_{63})$$ returns a 64 bit <a href="https://en.wikipedia.org/wiki/Rabin_fingerprint">Rabin
Fingerprint</a> of the byte
sequence in the argument (where $$b_i$$ is the byte at offset $$i$$). This
function can be efficiently computed as a <a href="https://en.wikipedia.org/wiki/Rolling_hash">rolling
hash</a>, which means that $$F(b_1 …
b_{64})$$ can be computed without much overhead when $$F(b_0 … b_{63})$$ is
already known. Restic uses 64 bytes as the &ldquo;window size&rdquo; for the rolling hash.</p>
<p>When restic saves a file, it first computes the Rabin Fingerprints for all 64
byte sequences in the file, so it starts by computing $$F(b_0 … b_{63})$$,
then $$F(b_1 … b_{64})$$, then $$F(b_2 … b_{65})$$ and so on. For each
fingerprint, restic then tests if the lowest 21 bits are zero. If this is the
case, restic found a new chunk boundary.</p>
<p>A chunk boundary therefore depends only on the last 64 bytes before the
boundary, in other words the end of a chunk depends on the last 64 bytes of a
chunk. This especially means that chunks are variable-sized, within reasonable
limits.</p>
<p>Returning to our earlier example, if a user creates a backup of a file and then
inserts bytes at the beginning of the file, restic will find the same chunk
boundary for the first chunk during the second run. The content of this first
chunk will have changed (due to the additional bytes), but any subsequent chunk
will remain identical thanks to the content-defined chunk boundaries.</p>
<p>Let&rsquo;s say our file consists of 4MiB of data, and restic detects the following
chunk boundaries, where &ldquo;offset&rdquo; is the byte offset of the last byte of the
sliding window:</p>
<table>
<thead>
<tr>
<th style="text-align:right">Offset</th>
<th style="text-align:right">Fingerprint</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">577536</td>
<td style="text-align:right"><code>0x77db45c60d400000</code></td>
</tr>
<tr>
<td style="text-align:right">1990656</td>
<td style="text-align:right"><code>0xc0da6ed30fe00000</code></td>
</tr>
<tr>
<td style="text-align:right">2945019</td>
<td style="text-align:right"><code>0x309235f507600000</code></td>
</tr>
<tr>
<td style="text-align:right">4194304</td>
<td style="text-align:right">End of File</td>
</tr>
</tbody>
</table>
<p>The file is therefore split into four chunks. Adding 20 bytes at the beginning
of the file still yields the same chunk boundaries, shifted by 20 bytes:</p>
<table>
<thead>
<tr>
<th style="text-align:right">Offset</th>
<th style="text-align:right">Fingerprint</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">577556</td>
<td style="text-align:right"><code>0x77db45c60d400000</code></td>
</tr>
<tr>
<td style="text-align:right">1990676</td>
<td style="text-align:right"><code>0xc0da6ed30fe00000</code></td>
</tr>
<tr>
<td style="text-align:right">2945039</td>
<td style="text-align:right"><code>0x309235f507600000</code></td>
</tr>
<tr>
<td style="text-align:right">4194304</td>
<td style="text-align:right">End of File</td>
</tr>
</tbody>
</table>
<p>When restic computes a cryptographic hash (SHA-256) over the data in each chunk,
it detects that the first chunk has been changed (we added 20 bytes, remember?),
but the remaining three chunks have the same hash. Therefore, it only needs to
save the changed first chunk.</p>
<h3 id="examples">Examples</h3>
<p>So, let&rsquo;s take the things explained above to the real world, and have a bit of
fun with restic. For the sake of simplicity, we&rsquo;ll save the repository location
and the password in environment variables (<code>RESTIC_REPOSITORY</code> and
<code>RESTIC_PASSWORD</code>) so that we don&rsquo;t have to type the password for every action:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ export RESTIC_REPOSITORY<span style="color:#f92672">=</span>/tmp/restic-test-repository RESTIC_PASSWORD<span style="color:#f92672">=</span>foo</span></span></code></pre></div>
<p>Please be aware that this way the password will be contained in your shell
history.</p>
<p>First, we&rsquo;ll initialize a new repository at a temporary location:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ restic init
</span></span><span style="display:flex;"><span>created restic backend 2b310bf378 at /tmp/restic-test-repository
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Please note that knowledge of your password is required to access
</span></span><span style="display:flex;"><span>the repository. Losing your password means that your data is
</span></span><span style="display:flex;"><span>irrecoverably lost.</span></span></code></pre></div>
<p>At this point, nothing has been saved to the repository, so it is rather small:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ du -sh $RESTIC_REPOSITORY
</span></span><span style="display:flex;"><span>8.0K	/tmp/restic-test-repository</span></span></code></pre></div>
<p>Next, we create a new directory called <code>testdata</code> for our test, containing a file
<code>file.raw</code>, filled with 100MiB of random data:
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ mkdir testdata
</span></span><span style="display:flex;"><span>$ dd <span style="color:#66d9ef">if</span><span style="color:#f92672">=</span>/dev/urandom of<span style="color:#f92672">=</span>testdata/file.raw bs<span style="color:#f92672">=</span>1M count<span style="color:#f92672">=</span><span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>100+0 records in
</span></span><span style="display:flex;"><span>100+0 records out
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">104857600</span> bytes <span style="color:#f92672">(</span><span style="color:#ae81ff">105</span> MB<span style="color:#f92672">)</span> copied, 5.76985 s, 18.2 MB/s</span></span></code></pre></div></p>
<p>We then backup this directory with restic (into the repository we specified via the
environment variable <code>$RESTIC_REPOSITORY</code> above):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ restic backup testdata
</span></span><span style="display:flex;"><span>scan <span style="color:#f92672">[</span>/home/fd0/tmp/testdata<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>scanned <span style="color:#ae81ff">1</span> directories, <span style="color:#ae81ff">1</span> files in 0:00
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>0:02<span style="color:#f92672">]</span> 100.00%  41.457 MiB/s  100.000 MiB / 100.000 MiB  <span style="color:#ae81ff">0</span> / <span style="color:#ae81ff">2</span> it...ETA 0:00
</span></span><span style="display:flex;"><span>duration: 0:02, 44.21MiB/s
</span></span><span style="display:flex;"><span>snapshot 7452bd17 saved</span></span></code></pre></div>
<p>We can see that restic created a backup with a size of 100MiB in about two
seconds. We can verify this by checking the size of the repository again:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ du -sh $RESTIC_REPOSITORY
</span></span><span style="display:flex;"><span>101M	/tmp/restic-test-repository</span></span></code></pre></div>
<p>Not surprisingly, the repository is roughly the same size as the data we have
created the backup of.</p>
<p>Now, we run the backup command for a second time:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ restic backup testdata
</span></span><span style="display:flex;"><span>using parent snapshot 7452bd17
</span></span><span style="display:flex;"><span>scan <span style="color:#f92672">[</span>/home/fd0/tmp/testdata<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>scanned <span style="color:#ae81ff">1</span> directories, <span style="color:#ae81ff">1</span> files in 0:00
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>0:00<span style="color:#f92672">]</span> 100.00%  0B/s  100.000 MiB / 100.000 MiB  <span style="color:#ae81ff">0</span> / <span style="color:#ae81ff">2</span> items  ... ETA 0:00
</span></span><span style="display:flex;"><span>duration: 0:00, 20478.98MiB/s
</span></span><span style="display:flex;"><span>snapshot 0b870550 saved</span></span></code></pre></div>
<p>Again we&rsquo;ve instructed restic to backup 100MiB of data, but in this case restic
was much faster and finished the job in less than a second.  By the way, restic
would have also been able to efficiently backup a file that was renamed or even
moved to a different directory.</p>
<p>Looking at the repository size we can already guess that it is still about
100MiB, since we didn&rsquo;t really add any new data:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ du -sh $RESTIC_REPOSITORY
</span></span><span style="display:flex;"><span>101M	/tmp/restic-test-repository</span></span></code></pre></div>
<p>When we make a copy of the file <code>file.raw</code> and backup the same repository again,
restic recognises that all data is already known and the repository size does
not grow at all, although the directory <code>testdata</code> now contains 200MiB of data:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ cp testdata/file.raw testdata/file2.raw
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ du -sh testdata
</span></span><span style="display:flex;"><span>200M	testdata
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ restic backup testdata
</span></span><span style="display:flex;"><span>using parent snapshot 0b870550
</span></span><span style="display:flex;"><span>scan <span style="color:#f92672">[</span>/home/fd0/tmp/testdata<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>scanned <span style="color:#ae81ff">1</span> directories, <span style="color:#ae81ff">2</span> files in 0:00
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>0:01<span style="color:#f92672">]</span> 100.00%  163.617 MiB/s  200.000 MiB / 200.000 MiB  <span style="color:#ae81ff">1</span> / <span style="color:#ae81ff">3</span> ... ETA 0:00
</span></span><span style="display:flex;"><span>duration: 0:01, 129.06MiB/s
</span></span><span style="display:flex;"><span>snapshot ab8e0047 saved
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ du -sh $RESTIC_REPOSITORY
</span></span><span style="display:flex;"><span>101M	/tmp/restic-test-repository</span></span></code></pre></div>
<p>Now for the final demonstration we&rsquo;ll create a new file <code>file3.raw</code> which is a
nasty combination of the 100MiB we&rsquo;ve initially saved in <code>file.raw</code> so that
<code>testdata</code> now contains about 400MiB:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ <span style="color:#f92672">(</span>echo foo; cat testdata/file.raw; echo bar; cat testdata/file.raw; echo baz<span style="color:#f92672">)</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  &gt; testdata/file3.raw
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ du -sh testdata
</span></span><span style="display:flex;"><span>401M	testdata</span></span></code></pre></div>
<p>We&rsquo;ll create a new backup of the directory with restic and observe that the
repository has grown by about 10MiB:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ restic backup testdata
</span></span><span style="display:flex;"><span>using parent snapshot ab8e0047
</span></span><span style="display:flex;"><span>scan <span style="color:#f92672">[</span>/home/fd0/tmp/testdata<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>scanned <span style="color:#ae81ff">1</span> directories, <span style="color:#ae81ff">3</span> files in 0:00
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>0:03<span style="color:#f92672">]</span> 100.00%  127.638 MiB/s  400.000 MiB / 400.000 MiB  <span style="color:#ae81ff">2</span> / <span style="color:#ae81ff">4</span> ... ETA 0:00
</span></span><span style="display:flex;"><span>duration: 0:03, 123.73MiB/s
</span></span><span style="display:flex;"><span>snapshot a8897ae3 saved
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ du -sh $RESTIC_REPOSITORY
</span></span><span style="display:flex;"><span>111M	/tmp/restic-test-repository</span></span></code></pre></div>
<p>This is expected because we&rsquo;ve created a few new chunks when creating
<code>file3.raw</code>, e.g. the first chunk will be saved again because a few bytes (the
string <code>foo\n</code>) were added. Restic managed this challenge quite well and only
introduced minor overhead for storing this incremental backup.</p>
<h3 id="conclusion">Conclusion</h3>
<p>Content Defined Chunking is a clever idea to split large amounts of data (e.g.
large files) into small chunks, while being able to recognize the same chunks
again when shifted or (slightly) modified.</p>
<p>This enables restic to de-duplicate data on the level of chunks so that each
chunk of data is only stored at (and transmitted to) the backup location once.
This gives us not only <em>inter-file</em> de-duplication, but also the more relevant
<em>inter-backup</em> de-duplication.</p>
<h3 id="references">References</h3>
<ul>
<li><a href="https://github.com/restic/chunker">The restic CDC implementation</a> and
<a href="http://godoc.org/github.com/restic/chunker">API documentation</a></li>
<li>Michael O. Rabin (1981): <a href="http://www.xmailserver.org/rabin.pdf">Fingerprinting by Random Polynomials</a></li>
<li>Ross N. Williams (1993): <a href="http://www.zlib.net/crc_v3.txt">A Painless Guide to CRC Error Detection Algorithms</a></li>
<li>Andrei Z. Broder (1993): <a href="http://www.xmailserver.org/rabin_apps.pdf">Some Applications of Rabin&rsquo;s Fingerprinting Method</a></li>
<li>Shuhong Gao and Daniel Panario (1997): <a href="http://www.math.clemson.edu/~sgao/papers/GP97a.pdf">Tests and Constructions of Irreducible Polynomials over Finite Fields</a></li>
<li>Andrew Kadatch, Bob Jenkins (2007): <a href="https://github.com/rurban/crcutil/raw/master/doc/crc.pdf">Everything we know about CRC but afraid to forget</a></li>
</ul>

      </div>

      <h2>Comments</h2>
      <div id='discourse-comments'></div>
      <script type="text/javascript">
        DiscourseEmbed = { discourseUrl: 'https://forum.restic.net/', discourseEmbedUrl: 'https:\/\/restic.net\/blog\/2015-09-12\/restic-foundation1-cdc\/' };

        (function() {
          var d = document.createElement('script'); d.type = 'text/javascript'; d.async = true;
          d.src = DiscourseEmbed.discourseUrl + 'javascripts/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(d);
        })();
      </script>

      <div class="related">
        <h2>Related Posts</h2>
        <div class="related-posts">
          
          <ul>
<li>
<p>21 Aug 2022 » <a href="/blog/2022-08-21/restic-0.14.0-released/">Restic 0.14.0 Released</a></p>
</li>
<li>
<p>10 Apr 2022 » <a href="/blog/2022-04-10/restic-0.13.1-released/">Restic 0.13.1 Released</a></p>
</li>
<li>
<p>26 Mar 2022 » <a href="/blog/2022-03-26/restic-0.13.0-released/">Restic 0.13.0 Released</a></p>
</li>
</ul>

        </div>
      </div>
    </div>

    <a href="https://github.com/restic/restic" class="desktop">
	<img style="position: fixed; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png">
</a>
  </body>
</html>
